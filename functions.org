* Functions

elispでの関数について

** defconst

#+BEGIN_SRC emacs-lisp
  (defconst SYMBOL INITVALUE [DOCSTRING])
#+END_SRC

=SYMBOL= を =INITVALUE= で定義

** defun

#+BEGIN_SRC emacs-lisp
  (defun NAME ARGLIST &optional DOCSTRING DECL &rest BODY)
#+END_SRC

=NAME= は関数名。
=(lambda ARGLIST [DOCSTRING] BODY...)= が定義となる。

** version<=

#+BEGIN_SRC emacs-lisp
  (version<= V1 V2)
#+END_SRC

=V1= のほうが =V2= よりもバージョンが小さければ =t= を返す

** require

#+BEGIN_SRC emacs-lisp
  (require FEATURE &optional FILENAME NOERROR)
#+END_SRC

=FEATURE= がまだロードされていなければ =FILENAME= から読み出す。
=FILENAME= が =nil= であれば、 =FEATURE= に =.elc= 、 =.el= を追加したファイルから読み出しを行う。
これについては、 =get-load-suffixes= を参照。
=NOERROR= が =nil= でなければ、ファイルが見つからなかったとしても、エラーを出さない。

** add-to-list

#+BEGIN_SRC emacs-lisp
  (add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FN)
#+END_SRC

=ELEMENT= が =LIST_VAR= に含まれていない場合追加。
=ELEMENT= が含まれているかどうかのテストは =equal= 関数で行われる。
もしくは =COMPARE-FN= が =nil= でない場合はそちらが使用される。
=APPEND= が =nil= でない場合は、末尾に追加、そうでない場合は先頭に追加する。

** expand-file-name

#+BEGIN_SRC emacs-lisp
  (expand-file-name NAME &optional DEFAULT-DIRECTORY)
#+END_SRC

=NAME= で指定されたファイルパスを絶対パスに展開

** concat

#+BEGIN_SRC emacs-lisp
  (concat &rest SEQUENCES)
#+END_SRC

=SEQUENCES= を連結してstringを返す

** unless

#+BEGIN_SRC emacs-lisp
  (unless COND BODY...)
#+END_SRC

=COND= が =nil= であれば、 =BODY= を実行し、そうでなければ =nil= を返す。
=BODY= を実行した際は、順に実行され、最後の値が返される。

** file-exists-p

#+BEGIN_SRC emacs-lisp
  (file-exists-p FILENAME)
#+END_SRC

=FILENAME= が存在すれば=t=を返す。
存在しないファイルへのシムリンクであれば =nil= を返す。


** make-directory

#+BEGIN_SRC emacs-lisp
  (make-directory DIR &optional PARENTS)
#+END_SRC

=DIR= のディレクトリを作成。

** mapc

#+BEGIN_SRC emacs-lisp
  (mapc FUNCTION SEQUENCE)
#+END_SRC

=SEQUENCE= の要素に =FUNCTION= を適用させる。
結果の値を返さず、 =SEQUENCE= が返される。

** current-time

#+BEGIN_SRC emacs-lisp
  (current-time)
#+END_SRC

=1970-01-01 00:00:00= からの経過秒を返す。
返される値は =(HIGH LOW USEC PSEC)= の形式。

HIGH has the most significant bits of the seconds, while LOW has the
least significant 16 bits.  USEC and PSEC are the microsecond and
picosecond counts.


** featurep

#+BEGIN_SRC emacs-lisp
  (featurep FEATURE &optional SUBFEATURE)
#+END_SRC

=FEATURE= が使用できる状態であれば =t= を返す。
=provide= を使うことで、使用可能状態であることを示す。 
この関数では =features= 変数をみる。
=SUBFEATURE= 変数は、 =FEATURE= のサブを示すために使用する。

** mapconcat

#+BEGIN_SRC emacs-lisp
  (mapconcat FUNCTION SEQUENCE SEPARATOR)
#+END_SRC

=FUNCTION= を =SEQUENCE= に適用し、返り値を結合したものを返す。

** identity

#+BEGIN_SRC emacs-lisp
  (identity ARG)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (identity 'aaa)
  -> aaa
  (mapconcat 'identity '("aaa" "bbb" "CCC") "/")
#+END_SRC

きた値をそのまま返す

** string-match

#+BEGIN_SRC emacs-lisp
  (string-match REGEXP STRING &optional START)
#+END_SRC

=REGEXP= に =STRING= 内で最初にマッチしたindexを返す。
マッチしなければnilを返す。
=START= が =nil= でなければ、そのindexから探索を開始する。

** replace-match

#+BEGIN_SRC emacs-lisp
(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)
#+END_SRC

最後のサーチでマッチした部分を =NEWTEXT＝ で置換する。

** defmacro

#+BEGIN_SRC emacs-lisp
  (defmacro NAME ARGLIST &optional DOCSTRING DECL &rest BODY)
#+END_SRC

=NAME= をマクロとして定義。
=(NAME ARGS..)= として、マクロが呼び出された場合は、 =(lambda ARGLIST BODY...)= として、 =ARGS...= に適用される。

** intern

#+BEGIN_SRC emacs-lisp
  (intern STRING &optional OBARRAY)
#+END_SRC

そもそも、名前のシンボルを探したり追加したりすることをインターンニングと呼ぶ。
この関数は、 =name= を名前とするインターンしたシンボルを返す。 
そのようなシンボルがオブジェクト配列 =obarray= に存在しなければ、
internは新たなものを作成し、それをオブジェクト配列に追加してから、 それを返す。 
obarrayを省略すると、グローバル変数obarrayの値を使う。

** set

#+BEGIN_SRC emacs-lisp
  (set SYMBOL NEWVAL)
#+END_SRC

シンボルの値を新しい値に変更して返す

** add-hook

#+BEGIN_SRC emacs-lisp
  (add-hook HOOK FUNCTION &optional APPEND LOCAL)
#+END_SRC

=HOOK= に =FUNCTION= を登録。
既に登録されている場合、 =FUNCTION= は登録されない。
=FUNCTION= は、 =APPEND= が =t= でないかぎり、フックの一番最初に追加。

=LOCAL= が =nil= でなければ、バッファローカルに登録される。


** make-variable-buffer-local

#+BEGIN_SRC emacs-lisp
  (make-variable-buffer-local VARIABLE)
#+END_SRC

バッファローカルな変数を作成。

** memq

#+BEGIN_SRC emacs-lisp
  (memq ELT LIST)
#+END_SRC

=ELT= が =LIST= に含まれていれば =nil= 以外をかえす。
比較は =eq= で行われる。

** deftheme

#+BEGIN_SRC emacs-lisp
  (deftheme THEME &optional DOC &rest IGNORED)
#+END_SRC

カスタムテーマを =THEME= として定義。
例えば、 =foo= というテーマは =foo-theme.el= というファイルで定義されているべき。

** assq

#+BEGIN_SRC emacs-lisp
  (assq KEY LIST)
#+END_SRC

=LIST= に含まれる cons の中で、 =car= が =KEY= と =eq= で =nil= 以外になるものがあれば、 =nil= 以外を返す。

#+BEGIN_SRC emacs-lisp
  (assq 'key1 '((key . key) (key1 . key1) (key2 . key2)))
#+END_SRC

** let*

#+BEGIN_SRC emacs-lisp
(let* VARLIST BODY...)
#+END_SRC

=VARLIST= として宣言された変数を定義し、 =BODY= を実行する。
=BODY= の最後に実行されたものが値として返される。
=VARLIST= の中身は、シンボル、 =(SYMBOL VALUEFORM)= 形式のリスト、である必要がある。


** load-theme

#+BEGIN_SRC emacs-lisp
  (load-theme THEME &optional NO-CONFIRM NO-ENABLE)
#+END_SRC

カスタムテーマのロード。
テーマファイルは =THEME-theme.el= という名前である必要がある。
=custom-theme-load-path= で指定されたディレクトリ内にある必要がある。

正しくロードされた場合は =t= を返す。そうでない場合は =nil= 。

** disable-theme

#+BEGIN_SRC emacs-lisp
(disable-theme THEME)
#+END_SRC

=THEME= によって、設定されたものをdisableに。

** append

#+BEGIN_SRC emacs-lisp
  (append &rest SEQUENCES)
#+END_SRC

追記

** pop

#+BEGIN_SRC emacs-lisp
  (pop PLACE)
#+END_SRC

最初のエレメントを取得。リストからは削除。

** message

#+BEGIN_SRC emacs-lisp
  (message FORMAT-STRING &rest ARGS)
#+END_SRC

=*Message*= に追記するのと、下にメッセージを表示。

** defadvice

#+BEGIN_SRC emacs-lisp
(defadvice FUNCTION ARGS &rest BODY)
#+END_SRC

完全なフォーマットはこちら

adviceを使うことで、現状ある関数を再定義することが可能。ただし、Emacs24.4 では、新しいアドバイス定義方法がある。

[[http://rubikitch.com/2014/10/30/nadvice/][nadvice]]を参考

#+BEGIN_SRC emacs-lisp
  (defadvice FUNCTION (CLASS NAME [POSITION] [ARGLIST] FLAG...)
    [DOCSTRING] [INTERACTIVE-FORM]
    BODY...)
#+END_SRC

長いので定義は省略

** fboundp

#+BEGIN_SRC emacs-lisp
  (fboundp SYMBOL)
#+END_SRC

シンボルに関数が定義されていれば =t=

** consp

#+BEGIN_SRC emacs-lisp
(consp OBJECT)
#+END_SRC

=OBJECT= がコンスセルであれば =t=

** keywordp

#+BEGIN_SRC emacs-lisp
(keywordp OBJECT)
#+END_SRC

=OBJECT= がキーワードであれば =t=

** nreverse

#+BEGIN_SRC emacs-lisp
(nreverse LIST)
#+END_SRC

逆順にして返す

#+BEGIN_SRC emacs-lisp
  (setq l '("aaa" "bbb" "ccc"))
  (nreverse l)
#+END_SRC




